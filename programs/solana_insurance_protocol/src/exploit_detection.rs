use anchor_lang::prelude::*;
use crate::ProtocolState;
use crate::{ProtocolInfo, ErrorCode};

#[account]
pub struct ExploitAlert {
    pub protocol: Pubkey,
    pub alert_time: i64,
    pub anomaly_type: u8,  // 1 = TVL drop, 2 = Price anomaly, 3 = Transaction volume
    pub severity: u8,      // 1-100 scale
    pub details: String,
    pub is_confirmed: bool,
    pub resolution_notes: String,
    pub bump: u8,
}

impl ExploitAlert {
    pub const SIZE: usize = 8 +     // discriminator
                           32 +     // protocol
                           8 +      // alert_time
                           1 +      // anomaly_type
                           1 +      // severity
                           100 +    // details (max 96 chars + 4 bytes for string length)
                           1 +      // is_confirmed
                           100 +    // resolution_notes (max 96 chars + 4 bytes for string length)
                           1;       // bump
}

// Anomaly types
pub const ANOMALY_TVL_DROP: u8 = 1;
pub const ANOMALY_PRICE: u8 = 2;
pub const ANOMALY_TX_VOLUME: u8 = 3;

pub fn create_exploit_alert(
    ctx: Context<CreateExploitAlert>,
    anomaly_type: u8,
    severity: u8,
    details: String,
) -> Result<()> {
    let exploit_alert = &mut ctx.accounts.exploit_alert;
    let clock = Clock::get()?;
    
    // Verify anomaly type is valid
    require!(
        anomaly_type == ANOMALY_TVL_DROP || 
        anomaly_type == ANOMALY_PRICE || 
        anomaly_type == ANOMALY_TX_VOLUME,
        ErrorCode::InvalidAnomalyType
    );
    
    // Verify severity is in range 1-100
    require!(severity > 0 && severity <= 100, ErrorCode::InvalidSeverity);
    
    // Only protocol authority or protocol monitoring oracles can create alerts
    require!(
        ctx.accounts.authority.key() == ctx.accounts.protocol_info.authority || 
        ctx.accounts.authority.key() == ctx.accounts.protocol_state.authority,
        ErrorCode::UnauthorizedAccess
    );
    
    // Initialize the alert
    exploit_alert.protocol = ctx.accounts.protocol_info.key();
    exploit_alert.alert_time = clock.unix_timestamp;
    exploit_alert.anomaly_type = anomaly_type;
    exploit_alert.severity = severity;
    exploit_alert.details = details;
    exploit_alert.is_confirmed = false;
    exploit_alert.resolution_notes = String::new();
    exploit_alert.bump = ctx.bumps.exploit_alert;
    
    Ok(())
}

pub fn resolve_exploit_alert(
    ctx: Context<ResolveExploitAlert>,
    is_confirmed: bool,
    resolution_notes: String,
) -> Result<()> {
    let exploit_alert = &mut ctx.accounts.exploit_alert;
    
    // Only protocol authority can resolve alerts
    require!(
        ctx.accounts.authority.key() == ctx.accounts.protocol_info.authority || 
        ctx.accounts.authority.key() == ctx.accounts.protocol_state.authority,
        ErrorCode::UnauthorizedAccess
    );
    
    // Update the alert
    exploit_alert.is_confirmed = is_confirmed;
    exploit_alert.resolution_notes = resolution_notes;
    
    Ok(())
}

#[derive(Accounts)]
pub struct CreateExploitAlert<'info> {
    #[account(mut)]
    pub authority: Signer<'info>,
    
    #[account(
        init,
        payer = authority,
        space = ExploitAlert::SIZE,
        seeds = [b"exploit-alert", protocol_info.key().as_ref(), &Clock::get()?.unix_timestamp.to_le_bytes()],
        bump
    )]
    pub exploit_alert: Account<'info, ExploitAlert>,
    
    pub protocol_info: Account<'info, ProtocolInfo>,
    
    #[account(
        seeds = [b"protocol-state"],
        bump
    )]
    pub protocol_state: Account<'info, ProtocolState>,
    
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct ResolveExploitAlert<'info> {
    #[account(mut)]
    pub authority: Signer<'info>,
    
    #[account(
        mut,
        seeds = [b"exploit-alert", protocol_info.key().as_ref(), &exploit_alert.alert_time.to_le_bytes()],
        bump = exploit_alert.bump
    )]
    pub exploit_alert: Account<'info, ExploitAlert>,
    
    pub protocol_info: Account<'info, ProtocolInfo>,
    
    #[account(
        seeds = [b"protocol-state"],
        bump
    )]
    pub protocol_state: Account<'info, ProtocolState>,
}